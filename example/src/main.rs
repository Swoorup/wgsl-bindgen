#![allow(dead_code)]
use std::iter;
use std::sync::Arc;
use std::time::Instant;

use futures::executor::block_on;
use winit::application::ApplicationHandler;
use winit::event::*;
use winit::event_loop::EventLoop;
use winit::keyboard::{KeyCode, PhysicalKey};
use winit::window::Window;

pub type MyTwoU32 = [u32; 2];

pub const SHADER_DIR: &str = include_absolute_path::include_absolute_path!("../shaders");

#[repr(C)]
#[derive(Debug, Clone, Copy, Default, PartialEq)]
pub struct MyScalars {
  a: u32,
  b: i32,
  c: f32,
}

// Include the bindings generated by build.rs.
mod demos;
mod overlay;
mod shader_bindings;
mod simple_text;

use demos::DemoManager;
use overlay::OverlayRenderer;
use wgpu::util::DeviceExt;

struct State {
  window: Arc<Window>,
  surface: wgpu::Surface<'static>,
  device: wgpu::Device,
  queue: wgpu::Queue,
  size: winit::dpi::PhysicalSize<u32>,
  config: wgpu::SurfaceConfiguration,
  demo_manager: DemoManager,
  overlay_renderer: OverlayRenderer,
  show_info: bool,
  info_display_time: Option<Instant>,
  start_time: Instant,
  global_time_buffer: wgpu::Buffer,
  global_bind_group: shader_bindings::global_bindings::WgpuBindGroup0,
  mouse_pos: glam::Vec2, // Mouse position in screen coordinates (-1 to 1)
}

impl State {
  async fn new(window: Window) -> Self {
    let window = Arc::new(window);
    let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
      backends: wgpu::Backends::all(),
      ..Default::default()
    });
    let surface = instance.create_surface(window.clone()).unwrap();
    let adapter = instance
      .request_adapter(&wgpu::RequestAdapterOptions {
        power_preference: wgpu::PowerPreference::default(),
        compatible_surface: Some(&surface),
        force_fallback_adapter: false,
      })
      .await
      .unwrap();

    // Check what limits are supported
    let limits = adapter.limits();
    println!("WebGPU Adapter Initialized");
    println!(
      "Max binding array elements per stage: {}",
      limits.max_binding_array_elements_per_shader_stage
    );
    println!(
      "Max binding array sampler elements per stage: {}",
      limits.max_binding_array_sampler_elements_per_shader_stage
    );

    let (device, queue) = adapter
      .request_device(&wgpu::DeviceDescriptor {
        label: None,
        required_features: wgpu::Features::TEXTURE_COMPRESSION_BC
          | wgpu::Features::PUSH_CONSTANTS
          | wgpu::Features::TEXTURE_BINDING_ARRAY,
        required_limits: wgpu::Limits {
          max_push_constant_size: 128,
          max_binding_array_elements_per_shader_stage: 4,
          max_binding_array_sampler_elements_per_shader_stage: 4,
          ..Default::default()
        },
        memory_hints: Default::default(),
        ..Default::default()
      })
      .await
      .unwrap();

    let size = window.inner_size();
    let caps = surface.get_capabilities(&adapter);
    let surface_format = caps.formats[0];
    let config = surface
      .get_default_config(&adapter, size.width, size.height)
      .unwrap();
    surface.configure(&device, &config);

    // Create global uniforms buffer and bind group
    let scale_factor = window.scale_factor() as f32;
    let frame_size = glam::Vec2::new(size.width as f32, size.height as f32);
    let global_uniforms = shader_bindings::global_bindings::GlobalUniforms::new(
      0.0, // time
      scale_factor,
      frame_size,
      glam::Vec2::new(0.0, 0.0), // initial mouse position
    );

    let global_time_buffer =
      device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("global uniforms buffer"),
        contents: bytemuck::cast_slice(&[global_uniforms]),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
      });

    let global_bind_group =
      shader_bindings::global_bindings::WgpuBindGroup0::from_bindings(
        &device,
        shader_bindings::global_bindings::WgpuBindGroup0Entries::new(
          shader_bindings::global_bindings::WgpuBindGroup0EntriesParams {
            globals: global_time_buffer.as_entire_buffer_binding(),
          },
        ),
      );

    // Initialize the demo manager with all available demos
    let demo_manager = DemoManager::new(&device, &queue, surface_format);

    // Create overlay renderer
    let mut overlay_renderer = OverlayRenderer::new(&device, surface_format);
    overlay_renderer.update_help_text(&device, &queue, demo_manager.get_help_text());

    // Set initial window title
    window.set_title(&format!(
      "wgsl_bindgen Shader Demos - {}",
      demo_manager.current_demo().name()
    ));

    // Don't print to console anymore, we'll show in overlay

    Self {
      surface,
      window,
      device,
      queue,
      size,
      config,
      demo_manager,
      overlay_renderer,
      show_info: true, // Show info on startup
      info_display_time: Some(Instant::now()),
      start_time: Instant::now(),
      global_time_buffer,
      global_bind_group,
      mouse_pos: glam::Vec2::new(0.0, 0.0),
    }
  }

  pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
    if new_size.width > 0 && new_size.height > 0 {
      self.size = new_size;
      self.config.width = new_size.width;
      self.config.height = new_size.height;
      self.surface.configure(&self.device, &self.config);

      // Update global uniforms with new frame size immediately
      let elapsed = self.start_time.elapsed().as_secs_f32();
      let scale_factor = self.window.scale_factor() as f32;
      let frame_size = glam::Vec2::new(new_size.width as f32, new_size.height as f32);
      let global_uniforms = shader_bindings::global_bindings::GlobalUniforms::new(
        elapsed,
        scale_factor,
        frame_size,
        self.mouse_pos,
      );

      self.queue.write_buffer(
        &self.global_time_buffer,
        0,
        bytemuck::cast_slice(&[global_uniforms]),
      );
    }
  }

  pub fn update_mouse_position(&mut self, position: winit::dpi::PhysicalPosition<f64>) {
    // Convert to normalized screen coordinates (-1 to 1)
    let x = (position.x as f32 / self.size.width as f32) * 2.0 - 1.0;
    let y = 1.0 - (position.y as f32 / self.size.height as f32) * 2.0; // Flip Y coordinate
    self.mouse_pos = glam::Vec2::new(x, y);

    // Debug: print occasionally to verify mouse updates
    static mut COUNTER: u32 = 0;
    unsafe {
      COUNTER += 1;
      if COUNTER.is_multiple_of(60) {
        // Print every 60 mouse moves
        println!(
          "Mouse: physical=({:.0}, {:.0}) window_size=({}, {}) normalized=({:.2}, {:.2})",
          position.x, position.y, self.size.width, self.size.height, x, y
        );
      }
    }
  }

  fn render(&mut self) -> Result<(), wgpu::SurfaceError> {
    let output = self.surface.get_current_texture()?;
    let output_view = output
      .texture
      .create_view(&wgpu::TextureViewDescriptor::default());

    // Calculate elapsed time in seconds
    let elapsed = self.start_time.elapsed().as_secs_f32();

    // Update global uniforms buffer
    let scale_factor = self.window.scale_factor() as f32;
    let frame_size = glam::Vec2::new(self.size.width as f32, self.size.height as f32);
    let global_uniforms = shader_bindings::global_bindings::GlobalUniforms::new(
      elapsed,
      scale_factor,
      frame_size,
      self.mouse_pos,
    );

    // Debug: occasionally print what we're sending to GPU
    static mut RENDER_COUNTER: u32 = 0;
    unsafe {
      RENDER_COUNTER += 1;
      if RENDER_COUNTER.is_multiple_of(180) {
        // Print every 3 seconds at 60fps
        println!(
          "GPU uniforms: mouse=({:.2}, {:.2}) frame_size=({:.0}, {:.0})",
          self.mouse_pos.x, self.mouse_pos.y, frame_size.x, frame_size.y
        );
      }
    }

    self.queue.write_buffer(
      &self.global_time_buffer,
      0,
      bytemuck::cast_slice(&[global_uniforms]),
    );

    // Update current demo with context
    let context = demos::DemoContext {
      elapsed_time: elapsed,
      mouse_pos: self.mouse_pos,
      frame_size,
    };
    self.demo_manager.update(&self.device, &self.queue, context);

    let mut encoder =
      self
        .device
        .create_command_encoder(&wgpu::CommandEncoderDescriptor {
          label: Some("Render Encoder"),
        });

    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
      label: Some("Render Pass"),
      color_attachments: &[Some(wgpu::RenderPassColorAttachment {
        view: &output_view,
        depth_slice: None,
        resolve_target: None,
        ops: wgpu::Operations {
          load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
          store: wgpu::StoreOp::Store,
        },
      })],
      depth_stencil_attachment: None,
      timestamp_writes: None,
      occlusion_query_set: None,
    });

    // Get info before borrowing for render
    let demo_index = self.demo_manager.current_demo_index() as u32;
    let demo_count = self.demo_manager.demo_count() as u32;

    // Set global bind group before rendering demos
    self.global_bind_group.set(&mut render_pass);

    // Render current demo
    self.demo_manager.render(&self.device, &mut render_pass);

    // Update overlay info with scale factor and window dimensions
    let scale_factor = self.window.scale_factor() as f32;
    self.overlay_renderer.update_info(
      &self.queue,
      demo_index,
      demo_count,
      elapsed,
      scale_factor,
      self.size.width as f32,
      self.size.height as f32,
    );

    // Render overlay if needed
    // Auto-hide overlay after 5 seconds
    if let Some(display_time) = self.info_display_time {
      if display_time.elapsed().as_secs() > 5 {
        self.show_info = false;
        self.info_display_time = None;
      }
    }
    self
      .overlay_renderer
      .render(&mut render_pass, self.show_info);

    drop(render_pass);
    self.queue.submit(iter::once(encoder.finish()));

    // Actually draw the frame.
    output.present();

    Ok(())
  }
}

fn main() {
  let event_loop = EventLoop::new().unwrap();
  let mut app = App { state: None };
  event_loop.run_app(&mut app).unwrap();
}

struct App {
  state: Option<State>,
}

impl ApplicationHandler<()> for App {
  fn resumed(&mut self, event_loop: &winit::event_loop::ActiveEventLoop) {
    if self.state.is_some() {
      return;
    }

    let window = event_loop
      .create_window(
        Window::default_attributes()
          .with_title("wgsl_bindgen Shader Demos")
          .with_min_inner_size(winit::dpi::LogicalSize::new(640, 480)) // Minimum usable size
          .with_inner_size(winit::dpi::LogicalSize::new(1024, 768)), // Good default size
      )
      .unwrap();

    self.state = Some(block_on(State::new(window)));
  }

  fn window_event(
    &mut self,
    event_loop: &winit::event_loop::ActiveEventLoop,
    window_id: winit::window::WindowId,
    event: WindowEvent,
  ) {
    // Window specific event handling.
    if let Some(state) = self.state.as_mut() {
      if window_id != state.window.id() {
        return;
      }

      match event {
        WindowEvent::CloseRequested => {
          event_loop.exit();
        }
        WindowEvent::KeyboardInput { event, .. } => {
          // Only handle key press events, not release
          if event.state == ElementState::Pressed {
            // Handle demo switching and pass input to current demo
            if state.demo_manager.handle_input(&event) {
              // Update window title when demo changes
              state.window.set_title(&format!(
                "wgsl_bindgen Shader Demos - {}",
                state.demo_manager.current_demo().name()
              ));
              // Update overlay text
              state.overlay_renderer.update_help_text(
                &state.device,
                &state.queue,
                state.demo_manager.get_help_text(),
              );
              // Show overlay when switching demos
              state.show_info = true;
              state.info_display_time = Some(Instant::now());
            }

            // Handle specific keys
            if let PhysicalKey::Code(key_code) = event.physical_key {
              match key_code {
                KeyCode::Escape => {
                  event_loop.exit();
                  return;
                }
                KeyCode::KeyH => {
                  // Toggle help overlay with 'H' key
                  state.show_info = !state.show_info;
                  if state.show_info {
                    state.info_display_time = Some(Instant::now());
                  } else {
                    state.info_display_time = None;
                  }
                }
                _ => {}
              }
            }
          }

          state.window.request_redraw();
        }
        WindowEvent::Resized(physical_size) => {
          state.resize(physical_size);
          state.window.request_redraw();
        }
        WindowEvent::CursorMoved { position, .. } => {
          state.update_mouse_position(position);
          state.window.request_redraw();
        }
        WindowEvent::ScaleFactorChanged { .. } => {}
        WindowEvent::RedrawRequested => {
          match state.render() {
            Ok(_) => {}
            Err(wgpu::SurfaceError::Lost) => state.resize(state.size),
            Err(wgpu::SurfaceError::OutOfMemory) => event_loop.exit(),
            Err(e) => eprintln!("{e:?}"),
          }
          state.window.request_redraw();
        }
        _ => {
          state.window.request_redraw();
        }
      }
    }
  }
}
