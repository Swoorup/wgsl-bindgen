// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.0
// Changes made to this file will not be saved.
// SourceHash: 82cb0f3508ed747301cbee8f93e2d976ff91e674b25617e3670fdb88f79168f7

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
  FullscreenEffects,
  SimpleArrayDemo,
  Overlay,
  GradientTriangle,
  ComputeDemoParticlePhysics,
  ComputeDemoParticleRenderer,
}
impl ShaderEntry {
  pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
    match self {
      Self::FullscreenEffects => fullscreen_effects::create_pipeline_layout(device),
      Self::SimpleArrayDemo => simple_array_demo::create_pipeline_layout(device),
      Self::Overlay => overlay::create_pipeline_layout(device),
      Self::GradientTriangle => gradient_triangle::create_pipeline_layout(device),
      Self::ComputeDemoParticlePhysics => {
        compute_demo::particle_physics::create_pipeline_layout(device)
      }
      Self::ComputeDemoParticleRenderer => {
        compute_demo::particle_renderer::create_pipeline_layout(device)
      }
    }
  }
  pub fn create_shader_module_relative_path(
    &self,
    device: &wgpu::Device,
    base_dir: &str,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
    match self {
      Self::FullscreenEffects => fullscreen_effects::create_shader_module_relative_path(
        device,
        base_dir,
        shader_defs,
        load_file,
      ),
      Self::SimpleArrayDemo => simple_array_demo::create_shader_module_relative_path(
        device,
        base_dir,
        shader_defs,
        load_file,
      ),
      Self::Overlay => overlay::create_shader_module_relative_path(
        device,
        base_dir,
        shader_defs,
        load_file,
      ),
      Self::GradientTriangle => gradient_triangle::create_shader_module_relative_path(
        device,
        base_dir,
        shader_defs,
        load_file,
      ),
      Self::ComputeDemoParticlePhysics => {
        compute_demo::particle_physics::create_shader_module_relative_path(
          device,
          base_dir,
          shader_defs,
          load_file,
        )
      }
      Self::ComputeDemoParticleRenderer => {
        compute_demo::particle_renderer::create_shader_module_relative_path(
          device,
          base_dir,
          shader_defs,
          load_file,
        )
      }
    }
  }
  pub fn relative_path(&self) -> &'static str {
    match self {
      Self::FullscreenEffects => fullscreen_effects::SHADER_ENTRY_PATH,
      Self::SimpleArrayDemo => simple_array_demo::SHADER_ENTRY_PATH,
      Self::Overlay => overlay::SHADER_ENTRY_PATH,
      Self::GradientTriangle => gradient_triangle::SHADER_ENTRY_PATH,
      Self::ComputeDemoParticlePhysics => {
        compute_demo::particle_physics::SHADER_ENTRY_PATH
      }
      Self::ComputeDemoParticleRenderer => {
        compute_demo::particle_renderer::SHADER_ENTRY_PATH
      }
    }
  }
  pub fn default_shader_defs(
  ) -> std::collections::HashMap<String, naga_oil::compose::ShaderDefValue> {
    std::collections::HashMap::new()
  }
  #[doc = r" Visits and processes all shader files in a dependency tree."]
  #[doc = r""]
  #[doc = r" This function traverses the shader dependency tree and calls the visitor function"]
  #[doc = r" for each file encountered. This allows for custom processing like hot reloading,"]
  #[doc = r" caching, or debugging."]
  #[doc = r""]
  #[doc = r" # Arguments"]
  #[doc = r""]
  #[doc = r" * `base_dir` - The base directory for resolving relative paths"]
  #[doc = r" * `load_file` - Function to load file contents from a path"]
  #[doc = r" * `visitor` - Function called for each file with (file_path, file_content)"]
  #[doc = r""]
  #[doc = r" # Returns"]
  #[doc = r""]
  #[doc = r" Returns `Ok(())` if all files were processed successfully, or an error string."]
  pub fn visit_shader_files(
    &self,
    base_dir: &str,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
    mut visitor: impl FnMut(&str, &str),
  ) -> Result<(), String> {
    fn visit_dependencies_recursive(
      base_dir: &str,
      source: &str,
      current_path: &str,
      load_file: &impl Fn(&str) -> Result<String, std::io::Error>,
      visitor: &mut impl FnMut(&str, &str),
      visited: &mut std::collections::HashSet<String>,
    ) -> Result<(), String> {
      let (_, imports, _) = naga_oil::compose::get_preprocessor_data(source);
      for import in imports {
        let import_path = if import.import.starts_with('\"') {
          import
            .import
            .chars()
            .skip(1)
            .take_while(|c| *c != '\"')
            .collect::<String>()
        } else {
          let module_path = import
            .import
            .split("::")
            .collect::<Vec<_>>()
            .join(std::path::MAIN_SEPARATOR_STR);
          format!("{module_path}.wgsl")
        };
        let full_import_path =
          if import_path.starts_with('/') || import_path.starts_with('\\') {
            format!("{base_dir}{import_path}")
          } else {
            std::path::Path::new(base_dir)
              .join(import_path)
              .display()
              .to_string()
          };
        if visited.contains(&full_import_path) {
          continue;
        }
        visited.insert(full_import_path.clone());
        let import_source = match load_file(&full_import_path) {
          Err(err) if err.kind() == std::io::ErrorKind::NotFound => {
            continue;
          }
          Err(err) => {
            return Err(format!("Failed to load import file {full_import_path}: {err}"));
          }
          Ok(content) => content,
        };
        visit_dependencies_recursive(
          base_dir,
          &import_source,
          full_import_path.trim_start_matches(&format!("{base_dir}/")),
          load_file,
          visitor,
          visited,
        )?;
        visitor(&full_import_path, &import_source);
      }
      Ok(())
    }
    let entry_path = format!("{}/{}", base_dir, self.relative_path());
    let entry_source = load_file(&entry_path)
      .map_err(|e| format!("Failed to load entry point {entry_path}: {e}"))?;
    visitor(&entry_path, &entry_source);
    let mut visited = std::collections::HashSet::new();
    visit_dependencies_recursive(
      base_dir,
      &entry_source,
      self.relative_path(),
      &load_file,
      &mut visitor,
      &mut visited,
    )?;
    Ok(())
  }
  pub fn load_naga_module_from_path_contents(
    &self,
    base_dir: &str,
    composer: &mut naga_oil::compose::Composer,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    files: Vec<(String, String)>,
  ) -> Result<wgpu::naga::Module, naga_oil::compose::ComposerError> {
    let entry_path = format!("{}/{}", base_dir, self.relative_path());
    for (file_path, file_content) in &files {
      if *file_path == entry_path {
        continue;
      }
      let relative_path = file_path.trim_start_matches(&format!("{base_dir}/"));
      let as_name = std::path::Path::new(relative_path)
        .with_extension("")
        .with_extension("")
        .iter()
        .flat_map(|s| s.to_str())
        .collect::<Vec<_>>()
        .join("::")
        .to_string();
      composer.add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
        source: file_content,
        file_path: relative_path,
        language: naga_oil::compose::ShaderLanguage::Wgsl,
        shader_defs: shader_defs.clone(),
        as_name: Some(as_name),
        ..Default::default()
      })?;
    }
    let (_, entry_source) = &files[0];
    composer.make_naga_module(naga_oil::compose::NagaModuleDescriptor {
      source: entry_source,
      file_path: self.relative_path(),
      shader_defs,
      ..Default::default()
    })
  }
  pub fn load_naga_module_from_path(
    &self,
    base_dir: &str,
    composer: &mut naga_oil::compose::Composer,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::naga::Module, String> {
    let mut files = Vec::<(String, String)>::new();
    self.visit_shader_files(base_dir, &load_file, |file_path, file_content| {
      files.push((file_path.to_string(), file_content.to_string()));
    })?;
    self
      .load_naga_module_from_path_contents(base_dir, composer, shader_defs, files)
      .map_err(|e| format!("{e}"))
  }
}
mod _root {
  pub use super::*;
  pub trait SetBindGroup {
    fn set_bind_group(
      &mut self,
      index: u32,
      bind_group: &wgpu::BindGroup,
      offsets: &[wgpu::DynamicOffset],
    );
  }
  impl SetBindGroup for wgpu::RenderPass<'_> {
    fn set_bind_group(
      &mut self,
      index: u32,
      bind_group: &wgpu::BindGroup,
      offsets: &[wgpu::DynamicOffset],
    ) {
      self.set_bind_group(index, bind_group, offsets);
    }
  }
  impl SetBindGroup for wgpu::RenderBundleEncoder<'_> {
    fn set_bind_group(
      &mut self,
      index: u32,
      bind_group: &wgpu::BindGroup,
      offsets: &[wgpu::DynamicOffset],
    ) {
      self.set_bind_group(index, bind_group, offsets);
    }
  }
  impl SetBindGroup for wgpu::ComputePass<'_> {
    fn set_bind_group(
      &mut self,
      index: u32,
      bind_group: &wgpu::BindGroup,
      offsets: &[wgpu::DynamicOffset],
    ) {
      self.set_bind_group(index, bind_group, offsets);
    }
  }
}
pub mod layout_asserts {
  use super::{_root, _root::*};
  const WGSL_BASE_TYPE_ASSERTS: () = {
    assert!(std::mem::size_of::<glam::IVec2>() == 8);
    assert!(std::mem::align_of::<glam::IVec2>() == 4);
    assert!(std::mem::size_of::<glam::IVec3>() == 12);
    assert!(std::mem::align_of::<glam::IVec3>() == 4);
    assert!(std::mem::size_of::<glam::IVec4>() == 16);
    assert!(std::mem::align_of::<glam::IVec4>() == 4);
    assert!(std::mem::size_of::<glam::UVec2>() == 8);
    assert!(std::mem::align_of::<glam::UVec2>() == 4);
    assert!(std::mem::size_of::<glam::UVec3>() == 12);
    assert!(std::mem::align_of::<glam::UVec3>() == 4);
    assert!(std::mem::size_of::<glam::UVec4>() == 16);
    assert!(std::mem::align_of::<glam::UVec4>() == 4);
    assert!(std::mem::size_of::<glam::Vec2>() == 8);
    assert!(std::mem::align_of::<glam::Vec2>() == 4);
    assert!(std::mem::size_of::<glam::Vec3>() == 12);
    assert!(std::mem::align_of::<glam::Vec3>() == 4);
    assert!(std::mem::size_of::<glam::Vec4>() == 16);
    assert!(std::mem::align_of::<glam::Vec4>() == 16);
    assert!(std::mem::size_of::<glam::Mat2>() == 16);
    assert!(std::mem::align_of::<glam::Mat2>() == 16);
    assert!(std::mem::size_of::<glam::Mat3A>() == 48);
    assert!(std::mem::align_of::<glam::Mat3A>() == 16);
    assert!(std::mem::size_of::<glam::Mat4>() == 64);
    assert!(std::mem::align_of::<glam::Mat4>() == 16);
  };
  const GLOBAL_BINDINGS_GLOBAL_UNIFORMS_ASSERTS: () = {
    assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, time) == 0);
    assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, scale_factor) == 4);
    assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, frame_size) == 8);
    assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, mouse_pos) == 16);
    assert!(std::mem::size_of::<global_bindings::GlobalUniforms>() == 24);
  };
  const FULLSCREEN_EFFECTS_UNIFORMS_ASSERTS: () = {
    assert!(std::mem::offset_of!(fullscreen_effects::Uniforms, color_rgb) == 0);
    assert!(std::mem::size_of::<fullscreen_effects::Uniforms>() == 16);
  };
  const FULLSCREEN_EFFECTS_PUSH_CONSTANTS_ASSERTS: () = {
    assert!(std::mem::offset_of!(fullscreen_effects::PushConstants, color_matrix) == 0);
    assert!(std::mem::size_of::<fullscreen_effects::PushConstants>() == 64);
  };
  const SIMPLE_ARRAY_DEMO_UNIFORMS_ASSERTS: () = {
    assert!(std::mem::offset_of!(simple_array_demo::Uniforms, color_rgb) == 0);
    assert!(std::mem::size_of::<simple_array_demo::Uniforms>() == 16);
  };
  const SIMPLE_ARRAY_DEMO_PUSH_CONSTANTS_ASSERTS: () = {
    assert!(std::mem::offset_of!(simple_array_demo::PushConstants, color_matrix) == 0);
    assert!(std::mem::size_of::<simple_array_demo::PushConstants>() == 64);
  };
  const OVERLAY_INFO_DATA_ASSERTS: () = {
    assert!(std::mem::offset_of!(overlay::InfoData, demo_index) == 0);
    assert!(std::mem::offset_of!(overlay::InfoData, total_demos) == 4);
    assert!(std::mem::offset_of!(overlay::InfoData, time) == 8);
    assert!(std::mem::offset_of!(overlay::InfoData, scale_factor) == 12);
    assert!(std::mem::offset_of!(overlay::InfoData, window_width) == 16);
    assert!(std::mem::offset_of!(overlay::InfoData, window_height) == 20);
    assert!(std::mem::offset_of!(overlay::InfoData, padding1) == 24);
    assert!(std::mem::offset_of!(overlay::InfoData, padding2) == 28);
    assert!(std::mem::size_of::<overlay::InfoData>() == 32);
  };
  const COMPUTE_DEMO_PARTICLE_PHYSICS_JOB_ASSERTS: () = {
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Job, position) == 0);
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Job, direction) == 16);
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Job, accum) == 32);
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Job, depth) == 44);
    assert!(std::mem::size_of::<compute_demo::particle_physics::Job>() == 48);
  };
  const COMPUTE_DEMO_PARTICLE_PHYSICS_PARAMS_ASSERTS: () = {
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Params, scale) == 0);
    assert!(std::mem::offset_of!(compute_demo::particle_physics::Params, damping) == 4);
    assert!(std::mem::size_of::<compute_demo::particle_physics::Params>() == 8);
  };
}
pub mod global_bindings {
  use super::{_root, _root::*};
  #[repr(C, align(8))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct GlobalUniforms {
    #[doc = "offset: 0, size: 4, type: `f32`"]
    pub time: f32,
    #[doc = "offset: 4, size: 4, type: `f32`"]
    pub scale_factor: f32,
    #[doc = "offset: 8, size: 8, type: `vec2<f32>`"]
    pub frame_size: glam::Vec2,
    #[doc = "offset: 16, size: 8, type: `vec2<f32>`"]
    pub mouse_pos: glam::Vec2,
  }
  impl GlobalUniforms {
    pub const fn new(
      time: f32,
      scale_factor: f32,
      frame_size: glam::Vec2,
      mouse_pos: glam::Vec2,
    ) -> Self {
      Self {
        time,
        scale_factor,
        frame_size,
        mouse_pos,
      }
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup0EntriesParams<'a> {
    pub globals: wgpu::BufferBinding<'a>,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup0Entries<'a> {
    pub globals: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup0Entries<'a> {
    pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
      Self {
        globals: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::Buffer(params.globals),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
      [self.globals]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup0(wgpu::BindGroup);
  impl WgpuBindGroup0 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("GlobalBindings::BindGroup0::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"_root::global_bindings::globals\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX
              .union(wgpu::ShaderStages::FRAGMENT)
              .union(wgpu::ShaderStages::COMPUTE),
            ty: wgpu::BindingType::Buffer {
              ty: wgpu::BufferBindingType::Uniform,
              has_dynamic_offset: false,
              min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                _root::global_bindings::GlobalUniforms,
              >() as _),
            },
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("GlobalBindings::BindGroup0"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(0, &self.0, &[]);
    }
  }
}
pub mod bytemuck_impls {
  use super::{_root, _root::*};
  unsafe impl bytemuck::Zeroable for global_bindings::GlobalUniforms {}
  unsafe impl bytemuck::Pod for global_bindings::GlobalUniforms {}
  unsafe impl bytemuck::Zeroable for fullscreen_effects::Uniforms {}
  unsafe impl bytemuck::Pod for fullscreen_effects::Uniforms {}
  unsafe impl bytemuck::Zeroable for fullscreen_effects::VertexInput {}
  unsafe impl bytemuck::Pod for fullscreen_effects::VertexInput {}
  unsafe impl bytemuck::Zeroable for fullscreen_effects::PushConstants {}
  unsafe impl bytemuck::Pod for fullscreen_effects::PushConstants {}
  unsafe impl bytemuck::Zeroable for simple_array_demo::Uniforms {}
  unsafe impl bytemuck::Pod for simple_array_demo::Uniforms {}
  unsafe impl bytemuck::Zeroable for simple_array_demo::VertexInput {}
  unsafe impl bytemuck::Pod for simple_array_demo::VertexInput {}
  unsafe impl bytemuck::Zeroable for simple_array_demo::PushConstants {}
  unsafe impl bytemuck::Pod for simple_array_demo::PushConstants {}
  unsafe impl bytemuck::Zeroable for overlay::InfoData {}
  unsafe impl bytemuck::Pod for overlay::InfoData {}
  unsafe impl bytemuck::Zeroable for gradient_triangle::VertexInput {}
  unsafe impl bytemuck::Pod for gradient_triangle::VertexInput {}
  unsafe impl bytemuck::Zeroable for compute_demo::particle_physics::Job {}
  unsafe impl bytemuck::Pod for compute_demo::particle_physics::Job {}
  unsafe impl bytemuck::Zeroable for compute_demo::particle_physics::Params {}
  unsafe impl bytemuck::Pod for compute_demo::particle_physics::Params {}
  unsafe impl bytemuck::Zeroable for compute_demo::particle_renderer::VertexInput {}
  unsafe impl bytemuck::Pod for compute_demo::particle_renderer::VertexInput {}
}
pub mod fullscreen_effects {
  use super::{_root, _root::*};
  #[repr(C, align(16))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct Uniforms {
    #[doc = "offset: 0, size: 16, type: `vec4<f32>`"]
    pub color_rgb: glam::Vec4,
  }
  pub const fn Uniforms(color_rgb: glam::Vec4) -> Uniforms {
    Uniforms { color_rgb }
  }
  #[repr(C)]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct VertexInput {
    pub position: glam::Vec3,
  }
  pub const fn VertexInput(position: glam::Vec3) -> VertexInput {
    VertexInput { position }
  }
  impl VertexInput {
    pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [wgpu::VertexAttribute {
      format: wgpu::VertexFormat::Float32x3,
      offset: std::mem::offset_of!(Self, position) as u64,
      shader_location: 0,
    }];
    pub const fn vertex_buffer_layout(
      step_mode: wgpu::VertexStepMode,
    ) -> wgpu::VertexBufferLayout<'static> {
      wgpu::VertexBufferLayout {
        array_stride: std::mem::size_of::<Self>() as u64,
        step_mode,
        attributes: &Self::VERTEX_ATTRIBUTES,
      }
    }
  }
  #[repr(C, align(16))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct PushConstants {
    #[doc = "offset: 0, size: 64, type: `mat4x4<f32>`"]
    pub color_matrix: glam::Mat4,
  }
  pub const fn PushConstants(color_matrix: glam::Mat4) -> PushConstants {
    PushConstants { color_matrix }
  }
  pub const ENTRY_VS_MAIN: &str = "vs_main";
  pub const ENTRY_FS_MAIN: &str = "fs_main";
  #[derive(Debug)]
  pub struct VertexEntry<const N: usize> {
    pub entry_point: &'static str,
    pub buffers: [wgpu::VertexBufferLayout<'static>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn vertex_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a VertexEntry<N>,
  ) -> wgpu::VertexState<'a> {
    wgpu::VertexState {
      module,
      entry_point: Some(entry.entry_point),
      buffers: &entry.buffers,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
    VertexEntry {
      entry_point: ENTRY_VS_MAIN,
      buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct FragmentEntry<const N: usize> {
    pub entry_point: &'static str,
    pub targets: [Option<wgpu::ColorTargetState>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn fragment_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a FragmentEntry<N>,
  ) -> wgpu::FragmentState<'a> {
    wgpu::FragmentState {
      module,
      entry_point: Some(entry.entry_point),
      targets: &entry.targets,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
    FragmentEntry {
      entry_point: ENTRY_FS_MAIN,
      targets,
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup1EntriesParams<'a> {
    pub main_texture: &'a wgpu::TextureView,
    pub main_sampler: &'a wgpu::Sampler,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup1Entries<'a> {
    pub main_texture: wgpu::BindGroupEntry<'a>,
    pub main_sampler: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup1Entries<'a> {
    pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
      Self {
        main_texture: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::TextureView(params.main_texture),
        },
        main_sampler: wgpu::BindGroupEntry {
          binding: 1,
          resource: wgpu::BindingResource::Sampler(params.main_sampler),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
      [self.main_texture, self.main_sampler]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup1(wgpu::BindGroup);
  impl WgpuBindGroup1 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("FullscreenEffects::BindGroup1::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"main_texture\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Texture {
              sample_type: wgpu::TextureSampleType::Float { filterable: true },
              view_dimension: wgpu::TextureViewDimension::D2,
              multisampled: false,
            },
            count: None,
          },
          #[doc = " @binding(1): \"main_sampler\""]
          wgpu::BindGroupLayoutEntry {
            binding: 1,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("FullscreenEffects::BindGroup1"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(1, &self.0, &[]);
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup2EntriesParams<'a> {
    pub uniforms: wgpu::BufferBinding<'a>,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup2Entries<'a> {
    pub uniforms: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup2Entries<'a> {
    pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
      Self {
        uniforms: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::Buffer(params.uniforms),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
      [self.uniforms]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup2(wgpu::BindGroup);
  impl WgpuBindGroup2 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("FullscreenEffects::BindGroup2::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"uniforms\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Buffer {
              ty: wgpu::BufferBindingType::Uniform,
              has_dynamic_offset: false,
              min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                _root::fullscreen_effects::Uniforms,
              >() as _),
            },
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("FullscreenEffects::BindGroup2"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(2, &self.0, &[]);
    }
  }
  #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
  #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
  #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
  #[doc = "   - Bind group 1: More frequent updates"]
  #[doc = "   - Bind group 2: More frequent updates"]
  #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
  #[derive(Debug, Copy, Clone)]
  pub struct WgpuBindGroups<'a> {
    pub bind_group0: &'a global_bindings::WgpuBindGroup0,
    pub bind_group1: &'a WgpuBindGroup1,
    pub bind_group2: &'a WgpuBindGroup2,
  }
  impl<'a> WgpuBindGroups<'a> {
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      self.bind_group0.set(pass);
      self.bind_group1.set(pass);
      self.bind_group2.set(pass);
    }
  }
  #[derive(Debug)]
  pub struct WgpuPipelineLayout;
  impl WgpuPipelineLayout {
    pub fn bind_group_layout_entries(
      entries: [wgpu::BindGroupLayout; 3],
    ) -> [wgpu::BindGroupLayout; 3] {
      entries
    }
  }
  pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
      label: Some("FullscreenEffects::PipelineLayout"),
      bind_group_layouts: &[
        &global_bindings::WgpuBindGroup0::get_bind_group_layout(device),
        &WgpuBindGroup1::get_bind_group_layout(device),
        &WgpuBindGroup2::get_bind_group_layout(device),
      ],
      push_constant_ranges: &[wgpu::PushConstantRange {
        stages: wgpu::ShaderStages::VERTEX_FRAGMENT,
        range: 0..64,
      }],
    })
  }
  pub const SHADER_ENTRY_PATH: &str = "fullscreen_effects.wgsl";
  pub fn create_shader_module_relative_path(
    device: &wgpu::Device,
    base_dir: &str,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
    let mut composer = naga_oil::compose::Composer::default()
      .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
    let module = ShaderEntry::FullscreenEffects
      .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
      .map_err(|e| naga_oil::compose::ComposerError {
        inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
        source: naga_oil::compose::ErrSource::Constructing {
          path: "load_naga_module_from_path".to_string(),
          source: "Generated code".to_string(),
          offset: 0,
        },
      })?;
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
      label: Some("fullscreen_effects.wgsl"),
      source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
    });
    Ok(shader_module)
  }
}
pub mod simple_array_demo {
  use super::{_root, _root::*};
  #[repr(C, align(16))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct Uniforms {
    #[doc = "offset: 0, size: 16, type: `vec4<f32>`"]
    pub color_rgb: glam::Vec4,
  }
  pub const fn Uniforms(color_rgb: glam::Vec4) -> Uniforms {
    Uniforms { color_rgb }
  }
  #[repr(C)]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct VertexInput {
    pub position: glam::Vec3,
  }
  pub const fn VertexInput(position: glam::Vec3) -> VertexInput {
    VertexInput { position }
  }
  impl VertexInput {
    pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [wgpu::VertexAttribute {
      format: wgpu::VertexFormat::Float32x3,
      offset: std::mem::offset_of!(Self, position) as u64,
      shader_location: 0,
    }];
    pub const fn vertex_buffer_layout(
      step_mode: wgpu::VertexStepMode,
    ) -> wgpu::VertexBufferLayout<'static> {
      wgpu::VertexBufferLayout {
        array_stride: std::mem::size_of::<Self>() as u64,
        step_mode,
        attributes: &Self::VERTEX_ATTRIBUTES,
      }
    }
  }
  #[repr(C, align(16))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct PushConstants {
    #[doc = "offset: 0, size: 64, type: `mat4x4<f32>`"]
    pub color_matrix: glam::Mat4,
  }
  pub const fn PushConstants(color_matrix: glam::Mat4) -> PushConstants {
    PushConstants { color_matrix }
  }
  pub const ENTRY_VS_MAIN: &str = "vs_main";
  pub const ENTRY_FS_MAIN: &str = "fs_main";
  #[derive(Debug)]
  pub struct VertexEntry<const N: usize> {
    pub entry_point: &'static str,
    pub buffers: [wgpu::VertexBufferLayout<'static>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn vertex_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a VertexEntry<N>,
  ) -> wgpu::VertexState<'a> {
    wgpu::VertexState {
      module,
      entry_point: Some(entry.entry_point),
      buffers: &entry.buffers,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
    VertexEntry {
      entry_point: ENTRY_VS_MAIN,
      buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct FragmentEntry<const N: usize> {
    pub entry_point: &'static str,
    pub targets: [Option<wgpu::ColorTargetState>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn fragment_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a FragmentEntry<N>,
  ) -> wgpu::FragmentState<'a> {
    wgpu::FragmentState {
      module,
      entry_point: Some(entry.entry_point),
      targets: &entry.targets,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
    FragmentEntry {
      entry_point: ENTRY_FS_MAIN,
      targets,
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup1EntriesParams<'a> {
    pub texture_array: &'a [&'a wgpu::TextureView],
    pub sampler_array: &'a [&'a wgpu::Sampler],
    pub texture_array_no_bind: &'a wgpu::TextureView,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup1Entries<'a> {
    pub texture_array: wgpu::BindGroupEntry<'a>,
    pub sampler_array: wgpu::BindGroupEntry<'a>,
    pub texture_array_no_bind: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup1Entries<'a> {
    pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
      Self {
        texture_array: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::TextureViewArray(params.texture_array),
        },
        sampler_array: wgpu::BindGroupEntry {
          binding: 1,
          resource: wgpu::BindingResource::SamplerArray(params.sampler_array),
        },
        texture_array_no_bind: wgpu::BindGroupEntry {
          binding: 2,
          resource: wgpu::BindingResource::TextureView(params.texture_array_no_bind),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
      [
        self.texture_array,
        self.sampler_array,
        self.texture_array_no_bind,
      ]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup1(wgpu::BindGroup);
  impl WgpuBindGroup1 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("SimpleArrayDemo::BindGroup1::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"texture_array\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Texture {
              sample_type: wgpu::TextureSampleType::Float { filterable: true },
              view_dimension: wgpu::TextureViewDimension::D2,
              multisampled: false,
            },
            count: Some(std::num::NonZeroU32::new(2u32).unwrap()),
          },
          #[doc = " @binding(1): \"sampler_array\""]
          wgpu::BindGroupLayoutEntry {
            binding: 1,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
            count: Some(std::num::NonZeroU32::new(2u32).unwrap()),
          },
          #[doc = " @binding(2): \"texture_array_no_bind\""]
          wgpu::BindGroupLayoutEntry {
            binding: 2,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Texture {
              sample_type: wgpu::TextureSampleType::Float { filterable: true },
              view_dimension: wgpu::TextureViewDimension::D2Array,
              multisampled: false,
            },
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("SimpleArrayDemo::BindGroup1"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(1, &self.0, &[]);
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup2EntriesParams<'a> {
    pub uniforms: wgpu::BufferBinding<'a>,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup2Entries<'a> {
    pub uniforms: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup2Entries<'a> {
    pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
      Self {
        uniforms: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::Buffer(params.uniforms),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
      [self.uniforms]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup2(wgpu::BindGroup);
  impl WgpuBindGroup2 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("SimpleArrayDemo::BindGroup2::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"uniforms\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Buffer {
              ty: wgpu::BufferBindingType::Uniform,
              has_dynamic_offset: false,
              min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                _root::simple_array_demo::Uniforms,
              >() as _),
            },
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("SimpleArrayDemo::BindGroup2"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(2, &self.0, &[]);
    }
  }
  #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
  #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
  #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
  #[doc = "   - Bind group 1: More frequent updates"]
  #[doc = "   - Bind group 2: More frequent updates"]
  #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
  #[derive(Debug, Copy, Clone)]
  pub struct WgpuBindGroups<'a> {
    pub bind_group0: &'a global_bindings::WgpuBindGroup0,
    pub bind_group1: &'a WgpuBindGroup1,
    pub bind_group2: &'a WgpuBindGroup2,
  }
  impl<'a> WgpuBindGroups<'a> {
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      self.bind_group0.set(pass);
      self.bind_group1.set(pass);
      self.bind_group2.set(pass);
    }
  }
  #[derive(Debug)]
  pub struct WgpuPipelineLayout;
  impl WgpuPipelineLayout {
    pub fn bind_group_layout_entries(
      entries: [wgpu::BindGroupLayout; 3],
    ) -> [wgpu::BindGroupLayout; 3] {
      entries
    }
  }
  pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
      label: Some("SimpleArrayDemo::PipelineLayout"),
      bind_group_layouts: &[
        &global_bindings::WgpuBindGroup0::get_bind_group_layout(device),
        &WgpuBindGroup1::get_bind_group_layout(device),
        &WgpuBindGroup2::get_bind_group_layout(device),
      ],
      push_constant_ranges: &[wgpu::PushConstantRange {
        stages: wgpu::ShaderStages::VERTEX_FRAGMENT,
        range: 0..64,
      }],
    })
  }
  pub const SHADER_ENTRY_PATH: &str = "simple_array_demo.wgsl";
  pub fn create_shader_module_relative_path(
    device: &wgpu::Device,
    base_dir: &str,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
    let mut composer = naga_oil::compose::Composer::default()
      .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
    let module = ShaderEntry::SimpleArrayDemo
      .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
      .map_err(|e| naga_oil::compose::ComposerError {
        inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
        source: naga_oil::compose::ErrSource::Constructing {
          path: "load_naga_module_from_path".to_string(),
          source: "Generated code".to_string(),
          offset: 0,
        },
      })?;
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
      label: Some("simple_array_demo.wgsl"),
      source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
    });
    Ok(shader_module)
  }
}
pub mod constants {
  use super::{_root, _root::*};
  pub const ONE: f32 = 1f32;
}
pub mod overlay {
  use super::{_root, _root::*};
  #[repr(C, align(4))]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct InfoData {
    #[doc = "offset: 0, size: 4, type: `f32`"]
    pub demo_index: f32,
    #[doc = "offset: 4, size: 4, type: `f32`"]
    pub total_demos: f32,
    #[doc = "offset: 8, size: 4, type: `f32`"]
    pub time: f32,
    #[doc = "offset: 12, size: 4, type: `f32`"]
    pub scale_factor: f32,
    #[doc = "offset: 16, size: 4, type: `f32`"]
    pub window_width: f32,
    #[doc = "offset: 20, size: 4, type: `f32`"]
    pub window_height: f32,
    #[doc = "offset: 24, size: 4, type: `f32`"]
    pub padding1: f32,
    #[doc = "offset: 28, size: 4, type: `f32`"]
    pub padding2: f32,
  }
  impl InfoData {
    pub const fn new(
      demo_index: f32,
      total_demos: f32,
      time: f32,
      scale_factor: f32,
      window_width: f32,
      window_height: f32,
      padding1: f32,
      padding2: f32,
    ) -> Self {
      Self {
        demo_index,
        total_demos,
        time,
        scale_factor,
        window_width,
        window_height,
        padding1,
        padding2,
      }
    }
  }
  pub const ENTRY_VS_MAIN: &str = "vs_main";
  pub const ENTRY_FS_MAIN: &str = "fs_main";
  #[derive(Debug)]
  pub struct VertexEntry<const N: usize> {
    pub entry_point: &'static str,
    pub buffers: [wgpu::VertexBufferLayout<'static>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn vertex_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a VertexEntry<N>,
  ) -> wgpu::VertexState<'a> {
    wgpu::VertexState {
      module,
      entry_point: Some(entry.entry_point),
      buffers: &entry.buffers,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn vs_main_entry() -> VertexEntry<0> {
    VertexEntry {
      entry_point: ENTRY_VS_MAIN,
      buffers: [],
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct FragmentEntry<const N: usize> {
    pub entry_point: &'static str,
    pub targets: [Option<wgpu::ColorTargetState>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn fragment_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a FragmentEntry<N>,
  ) -> wgpu::FragmentState<'a> {
    wgpu::FragmentState {
      module,
      entry_point: Some(entry.entry_point),
      targets: &entry.targets,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
    FragmentEntry {
      entry_point: ENTRY_FS_MAIN,
      targets,
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup0EntriesParams<'a> {
    pub info: wgpu::BufferBinding<'a>,
    pub text_texture: &'a wgpu::TextureView,
    pub text_sampler: &'a wgpu::Sampler,
  }
  #[derive(Clone, Debug)]
  pub struct WgpuBindGroup0Entries<'a> {
    pub info: wgpu::BindGroupEntry<'a>,
    pub text_texture: wgpu::BindGroupEntry<'a>,
    pub text_sampler: wgpu::BindGroupEntry<'a>,
  }
  impl<'a> WgpuBindGroup0Entries<'a> {
    pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
      Self {
        info: wgpu::BindGroupEntry {
          binding: 0,
          resource: wgpu::BindingResource::Buffer(params.info),
        },
        text_texture: wgpu::BindGroupEntry {
          binding: 1,
          resource: wgpu::BindingResource::TextureView(params.text_texture),
        },
        text_sampler: wgpu::BindGroupEntry {
          binding: 2,
          resource: wgpu::BindingResource::Sampler(params.text_sampler),
        },
      }
    }
    pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
      [self.info, self.text_texture, self.text_sampler]
    }
    pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
      self.into_array().into_iter().collect()
    }
  }
  #[derive(Debug)]
  pub struct WgpuBindGroup0(wgpu::BindGroup);
  impl WgpuBindGroup0 {
    pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
      wgpu::BindGroupLayoutDescriptor {
        label: Some("Overlay::BindGroup0::LayoutDescriptor"),
        entries: &[
          #[doc = " @binding(0): \"info\""]
          wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Buffer {
              ty: wgpu::BufferBindingType::Uniform,
              has_dynamic_offset: false,
              min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                _root::overlay::InfoData,
              >() as _),
            },
            count: None,
          },
          #[doc = " @binding(1): \"text_texture\""]
          wgpu::BindGroupLayoutEntry {
            binding: 1,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Texture {
              sample_type: wgpu::TextureSampleType::Float { filterable: true },
              view_dimension: wgpu::TextureViewDimension::D2,
              multisampled: false,
            },
            count: None,
          },
          #[doc = " @binding(2): \"text_sampler\""]
          wgpu::BindGroupLayoutEntry {
            binding: 2,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
            count: None,
          },
        ],
      };
    pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
      device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
    }
    pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
      let bind_group_layout = Self::get_bind_group_layout(device);
      let entries = bindings.into_array();
      let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("Overlay::BindGroup0"),
        layout: &bind_group_layout,
        entries: &entries,
      });
      Self(bind_group)
    }
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      pass.set_bind_group(0, &self.0, &[]);
    }
  }
  #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
  #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
  #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
  #[doc = "   - Bind group 1: More frequent updates"]
  #[doc = "   - Bind group 2: More frequent updates"]
  #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
  #[derive(Debug, Copy, Clone)]
  pub struct WgpuBindGroups<'a> {
    pub bind_group0: &'a WgpuBindGroup0,
  }
  impl<'a> WgpuBindGroups<'a> {
    pub fn set(&self, pass: &mut impl SetBindGroup) {
      self.bind_group0.set(pass);
    }
  }
  #[derive(Debug)]
  pub struct WgpuPipelineLayout;
  impl WgpuPipelineLayout {
    pub fn bind_group_layout_entries(
      entries: [wgpu::BindGroupLayout; 1],
    ) -> [wgpu::BindGroupLayout; 1] {
      entries
    }
  }
  pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
      label: Some("Overlay::PipelineLayout"),
      bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
      push_constant_ranges: &[],
    })
  }
  pub const SHADER_ENTRY_PATH: &str = "overlay.wgsl";
  pub fn create_shader_module_relative_path(
    device: &wgpu::Device,
    base_dir: &str,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
    let mut composer = naga_oil::compose::Composer::default()
      .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
    let module = ShaderEntry::Overlay
      .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
      .map_err(|e| naga_oil::compose::ComposerError {
        inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
        source: naga_oil::compose::ErrSource::Constructing {
          path: "load_naga_module_from_path".to_string(),
          source: "Generated code".to_string(),
          offset: 0,
        },
      })?;
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
      label: Some("overlay.wgsl"),
      source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
    });
    Ok(shader_module)
  }
}
pub mod gradient_triangle {
  use super::{_root, _root::*};
  #[repr(C)]
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub struct VertexInput {
    pub position: glam::Vec3,
    pub texture_id: u32,
  }
  pub const fn VertexInput(position: glam::Vec3, texture_id: u32) -> VertexInput {
    VertexInput {
      position,
      texture_id,
    }
  }
  impl VertexInput {
    pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 2] = [
      wgpu::VertexAttribute {
        format: wgpu::VertexFormat::Float32x3,
        offset: std::mem::offset_of!(Self, position) as u64,
        shader_location: 0,
      },
      wgpu::VertexAttribute {
        format: wgpu::VertexFormat::Uint32,
        offset: std::mem::offset_of!(Self, texture_id) as u64,
        shader_location: 1,
      },
    ];
    pub const fn vertex_buffer_layout(
      step_mode: wgpu::VertexStepMode,
    ) -> wgpu::VertexBufferLayout<'static> {
      wgpu::VertexBufferLayout {
        array_stride: std::mem::size_of::<Self>() as u64,
        step_mode,
        attributes: &Self::VERTEX_ATTRIBUTES,
      }
    }
  }
  pub const ENTRY_VS_MAIN: &str = "vs_main";
  pub const ENTRY_FS_MAIN: &str = "fs_main";
  #[derive(Debug)]
  pub struct VertexEntry<const N: usize> {
    pub entry_point: &'static str,
    pub buffers: [wgpu::VertexBufferLayout<'static>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn vertex_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a VertexEntry<N>,
  ) -> wgpu::VertexState<'a> {
    wgpu::VertexState {
      module,
      entry_point: Some(entry.entry_point),
      buffers: &entry.buffers,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
    VertexEntry {
      entry_point: ENTRY_VS_MAIN,
      buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct FragmentEntry<const N: usize> {
    pub entry_point: &'static str,
    pub targets: [Option<wgpu::ColorTargetState>; N],
    pub constants: Vec<(&'static str, f64)>,
  }
  pub fn fragment_state<'a, const N: usize>(
    module: &'a wgpu::ShaderModule,
    entry: &'a FragmentEntry<N>,
  ) -> wgpu::FragmentState<'a> {
    wgpu::FragmentState {
      module,
      entry_point: Some(entry.entry_point),
      targets: &entry.targets,
      compilation_options: wgpu::PipelineCompilationOptions {
        constants: &entry.constants,
        ..Default::default()
      },
    }
  }
  pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
    FragmentEntry {
      entry_point: ENTRY_FS_MAIN,
      targets,
      constants: Default::default(),
    }
  }
  #[derive(Debug)]
  pub struct WgpuPipelineLayout;
  impl WgpuPipelineLayout {
    pub fn bind_group_layout_entries(
      entries: [wgpu::BindGroupLayout; 0],
    ) -> [wgpu::BindGroupLayout; 0] {
      entries
    }
  }
  pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
      label: Some("GradientTriangle::PipelineLayout"),
      bind_group_layouts: &[],
      push_constant_ranges: &[],
    })
  }
  pub const SHADER_ENTRY_PATH: &str = "gradient_triangle.wgsl";
  pub fn create_shader_module_relative_path(
    device: &wgpu::Device,
    base_dir: &str,
    shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    load_file: impl Fn(&str) -> Result<String, std::io::Error>,
  ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
    let mut composer = naga_oil::compose::Composer::default()
      .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
    let module = ShaderEntry::GradientTriangle
      .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
      .map_err(|e| naga_oil::compose::ComposerError {
        inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
        source: naga_oil::compose::ErrSource::Constructing {
          path: "load_naga_module_from_path".to_string(),
          source: "Generated code".to_string(),
          offset: 0,
        },
      })?;
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
      label: Some("gradient_triangle.wgsl"),
      source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
    });
    Ok(shader_module)
  }
}
pub mod compute_demo {
  use super::{_root, _root::*};
  pub mod particle_physics {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Job {
      #[doc = "offset: 0, size: 12, type: `vec3<f32>`"]
      pub position: glam::Vec3,
      pub _pad_position: [u8; 0x4],
      #[doc = "offset: 16, size: 12, type: `vec3<f32>`"]
      pub direction: glam::Vec3,
      pub _pad_direction: [u8; 0x4],
      #[doc = "offset: 32, size: 12, type: `vec3<f32>`"]
      pub accum: glam::Vec3,
      #[doc = "offset: 44, size: 4, type: `u32`"]
      pub depth: u32,
    }
    impl Job {
      pub const fn new(
        position: glam::Vec3,
        direction: glam::Vec3,
        accum: glam::Vec3,
        depth: u32,
      ) -> Self {
        Self {
          position,
          _pad_position: [0; 0x4],
          direction,
          _pad_direction: [0; 0x4],
          accum,
          depth,
        }
      }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct JobInit {
      pub position: glam::Vec3,
      pub direction: glam::Vec3,
      pub accum: glam::Vec3,
      pub depth: u32,
    }
    impl JobInit {
      pub fn build(&self) -> Job {
        Job {
          position: self.position,
          _pad_position: [0; 0x4],
          direction: self.direction,
          _pad_direction: [0; 0x4],
          accum: self.accum,
          depth: self.depth,
        }
      }
    }
    impl From<JobInit> for Job {
      fn from(data: JobInit) -> Self {
        data.build()
      }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
      #[doc = "offset: 0, size: 4, type: `f32`"]
      pub scale: f32,
      #[doc = "offset: 4, size: 4, type: `f32`"]
      pub damping: f32,
    }
    pub const fn Params(scale: f32, damping: f32) -> Params {
      Params { scale, damping }
    }
    pub const DT: f32 = 0.012f32;
    pub const BOUNDARY: f32 = 1f32;
    pub const NEIGHBOR_RADIUS: f32 = 0.12f32;
    pub const SEPARATION_RADIUS: f32 = 0.06f32;
    pub const MAX_SPEED: f32 = 1f32;
    pub const MAX_FORCE: f32 = 0.08f32;
    pub const MOUSE_FORCE_RADIUS: f32 = 0.3f32;
    pub const MOUSE_FORCE_STRENGTH: f32 = 1.2f32;
    pub mod compute {
      use super::{_root, _root::*};
      pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
      pub fn create_main_pipeline_relative_path(
        device: &wgpu::Device,
        base_dir: &str,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
        load_file: impl Fn(&str) -> Result<String, std::io::Error>,
      ) -> Result<wgpu::ComputePipeline, naga_oil::compose::ComposerError> {
        let module = super::create_shader_module_relative_path(
          device,
          base_dir,
          shader_defs,
          load_file,
        )?;
        let layout = super::create_pipeline_layout(device);
        Ok(device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
          label: Some("Compute Pipeline main"),
          layout: Some(&layout),
          module: &module,
          entry_point: Some("main"),
          compilation_options: Default::default(),
          cache: None,
        }))
      }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
      pub jobs: wgpu::BufferBinding<'a>,
      pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
      pub jobs: wgpu::BindGroupEntry<'a>,
      pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
      pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
        Self {
          jobs: wgpu::BindGroupEntry {
            binding: 0,
            resource: wgpu::BindingResource::Buffer(params.jobs),
          },
          params: wgpu::BindGroupEntry {
            binding: 1,
            resource: wgpu::BindingResource::Buffer(params.params),
          },
        }
      }
      pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
        [self.jobs, self.params]
      }
      pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
        self.into_array().into_iter().collect()
      }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
      pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
        wgpu::BindGroupLayoutDescriptor {
          label: Some("ComputeDemoParticlePhysics::BindGroup1::LayoutDescriptor"),
          entries: &[
            #[doc = " @binding(0): \"jobs\""]
            wgpu::BindGroupLayoutEntry {
              binding: 0,
              visibility: wgpu::ShaderStages::COMPUTE,
              ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage { read_only: false },
                has_dynamic_offset: false,
                min_binding_size: None,
              },
              count: None,
            },
            #[doc = " @binding(1): \"params\""]
            wgpu::BindGroupLayoutEntry {
              binding: 1,
              visibility: wgpu::ShaderStages::COMPUTE,
              ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                  _root::compute_demo::particle_physics::Params,
                >() as _),
              },
              count: None,
            },
          ],
        };
      pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
        device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
      }
      pub fn from_bindings(
        device: &wgpu::Device,
        bindings: WgpuBindGroup1Entries,
      ) -> Self {
        let bind_group_layout = Self::get_bind_group_layout(device);
        let entries = bindings.into_array();
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
          label: Some("ComputeDemoParticlePhysics::BindGroup1"),
          layout: &bind_group_layout,
          entries: &entries,
        });
        Self(bind_group)
      }
      pub fn set(&self, pass: &mut impl SetBindGroup) {
        pass.set_bind_group(1, &self.0, &[]);
      }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
      pub bind_group0: &'a global_bindings::WgpuBindGroup0,
      pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
      pub fn set(&self, pass: &mut impl SetBindGroup) {
        self.bind_group0.set(pass);
        self.bind_group1.set(pass);
      }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
      pub fn bind_group_layout_entries(
        entries: [wgpu::BindGroupLayout; 2],
      ) -> [wgpu::BindGroupLayout; 2] {
        entries
      }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
      device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("ComputeDemoParticlePhysics::PipelineLayout"),
        bind_group_layouts: &[
          &global_bindings::WgpuBindGroup0::get_bind_group_layout(device),
          &WgpuBindGroup1::get_bind_group_layout(device),
        ],
        push_constant_ranges: &[],
      })
    }
    pub const SHADER_ENTRY_PATH: &str = "compute_demo/particle_physics.wgsl";
    pub fn create_shader_module_relative_path(
      device: &wgpu::Device,
      base_dir: &str,
      shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
      load_file: impl Fn(&str) -> Result<String, std::io::Error>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
      let mut composer = naga_oil::compose::Composer::default()
        .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
      let module = ShaderEntry::ComputeDemoParticlePhysics
        .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
        .map_err(|e| naga_oil::compose::ComposerError {
          inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
          source: naga_oil::compose::ErrSource::Constructing {
            path: "load_naga_module_from_path".to_string(),
            source: "Generated code".to_string(),
            offset: 0,
          },
        })?;
      let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("particle_physics.wgsl"),
        source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
      });
      Ok(shader_module)
    }
  }
  pub mod particle_renderer {
    use super::{_root, _root::*};
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VertexInput {
      pub quad_pos: glam::Vec2,
      pub position_and_size: glam::Vec4,
    }
    pub const fn VertexInput(
      quad_pos: glam::Vec2,
      position_and_size: glam::Vec4,
    ) -> VertexInput {
      VertexInput {
        quad_pos,
        position_and_size,
      }
    }
    impl VertexInput {
      pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 2] = [
        wgpu::VertexAttribute {
          format: wgpu::VertexFormat::Float32x2,
          offset: std::mem::offset_of!(Self, quad_pos) as u64,
          shader_location: 0,
        },
        wgpu::VertexAttribute {
          format: wgpu::VertexFormat::Float32x4,
          offset: std::mem::offset_of!(Self, position_and_size) as u64,
          shader_location: 1,
        },
      ];
      pub const fn vertex_buffer_layout(
        step_mode: wgpu::VertexStepMode,
      ) -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
          array_stride: std::mem::size_of::<Self>() as u64,
          step_mode,
          attributes: &Self::VERTEX_ATTRIBUTES,
        }
      }
    }
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
      pub entry_point: &'static str,
      pub buffers: [wgpu::VertexBufferLayout<'static>; N],
      pub constants: Vec<(&'static str, f64)>,
    }
    pub fn vertex_state<'a, const N: usize>(
      module: &'a wgpu::ShaderModule,
      entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
      wgpu::VertexState {
        module,
        entry_point: Some(entry.entry_point),
        buffers: &entry.buffers,
        compilation_options: wgpu::PipelineCompilationOptions {
          constants: &entry.constants,
          ..Default::default()
        },
      }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
      VertexEntry {
        entry_point: ENTRY_VS_MAIN,
        buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
        constants: Default::default(),
      }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
      pub entry_point: &'static str,
      pub targets: [Option<wgpu::ColorTargetState>; N],
      pub constants: Vec<(&'static str, f64)>,
    }
    pub fn fragment_state<'a, const N: usize>(
      module: &'a wgpu::ShaderModule,
      entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
      wgpu::FragmentState {
        module,
        entry_point: Some(entry.entry_point),
        targets: &entry.targets,
        compilation_options: wgpu::PipelineCompilationOptions {
          constants: &entry.constants,
          ..Default::default()
        },
      }
    }
    pub fn fs_main_entry(
      targets: [Option<wgpu::ColorTargetState>; 1],
    ) -> FragmentEntry<1> {
      FragmentEntry {
        entry_point: ENTRY_FS_MAIN,
        targets,
        constants: Default::default(),
      }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
      pub bind_group0: &'a global_bindings::WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
      pub fn set(&self, pass: &mut impl SetBindGroup) {
        self.bind_group0.set(pass);
      }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
      pub fn bind_group_layout_entries(
        entries: [wgpu::BindGroupLayout; 1],
      ) -> [wgpu::BindGroupLayout; 1] {
        entries
      }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
      device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("ComputeDemoParticleRenderer::PipelineLayout"),
        bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(
          device,
        )],
        push_constant_ranges: &[],
      })
    }
    pub const SHADER_ENTRY_PATH: &str = "compute_demo/particle_renderer.wgsl";
    pub fn create_shader_module_relative_path(
      device: &wgpu::Device,
      base_dir: &str,
      shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
      load_file: impl Fn(&str) -> Result<String, std::io::Error>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
      let mut composer = naga_oil::compose::Composer::default()
        .with_capabilities(wgpu::naga::valid::Capabilities::PUSH_CONSTANT);
      let module = ShaderEntry::ComputeDemoParticleRenderer
        .load_naga_module_from_path(base_dir, &mut composer, shader_defs, load_file)
        .map_err(|e| naga_oil::compose::ComposerError {
          inner: naga_oil::compose::ComposerErrorInner::ImportNotFound(e, 0),
          source: naga_oil::compose::ErrSource::Constructing {
            path: "load_naga_module_from_path".to_string(),
            source: "Generated code".to_string(),
            offset: 0,
          },
        })?;
      let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("particle_renderer.wgsl"),
        source: wgpu::ShaderSource::Naga(std::borrow::Cow::Owned(module)),
      });
      Ok(shader_module)
    }
  }
}
